---
title: "03_map_data"
author: "KP"
date: "2025-10-05"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,        # ukrywa kod
  warning = FALSE,     # ukrywa ostrze≈ºenia
  message = FALSE,     # ukrywa komunikaty
  error = FALSE        # ukrywa b≈Çƒôdy (pokazuje puste miejsce zamiast komunikatu b≈Çƒôdu)
)
```

```{r}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(gt)
library(tidyr)
library(psych)
# pakiety (odkomentuj instalacjƒô je≈õli potrzeba)

library(vegan)     # vegdist (Jaccard)
    # tetrachoric
library(cluster)
```


```{r}
load("all_data.rda")

all_map_data <- all_data %>% 
  select(starts_with("m_")) %>% 
  filter(!is.na(m_scale))
 
```

```{r}
# zamiana na tablicƒô binarnƒÖ (tylko 0 i 1)
all_map_data_bin <- all_map_data %>%
  select(-m_landmark_chimney) %>%  #usuniƒôto zmiennƒÖ, bo odpowiedzi by≈Çy tylko i wy≈ÇƒÖcznie nie
  mutate(across(everything(), ~ ifelse(. %in% c("tak", "du≈ºa"), 1L,
                                 ifelse(. %in% c("nie", "ma≈Ça"), 0L, .))))
```


```{r}
# Example: compute mean for each numeric variable
mean_data <- all_map_data_bin %>%
  summarise(across(where(is.numeric), mean, na.rm = TRUE)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Mean")

# Check the resulting data
print(mean_data)

# Plot with ggplot2
ggplot(mean_data, aes(x = reorder(Variable, Mean), y = Mean)) +
  geom_col(fill = "steelblue") +
  coord_flip() +  # flip for better readability
  labs(
    title = "Mean Value of Each Variable",
    x = "Variable",
    y = "Mean"
  ) +
  theme_minimal()
```

# korelacje

```{r}
# 1. Oblicz korelacjƒô (dla wszystkich kolumn)
cor_mat <- cor(all_map_data_bin, use = "pairwise.complete.obs", method = "pearson")

# 2. (opcjonalnie) posortuj zmienne wg podobie≈Ñstwa (klastrowanie)
hc <- hclust(dist(1 - cor_mat))  # im wiƒôksza korelacja, tym mniejszy dystans
var_order <- hc$labels[hc$order]
cor_mat <- cor_mat[var_order, var_order]

# 3. Zamiana macierzy na format "long"
cor_long <- as.data.frame(as.table(cor_mat))
colnames(cor_long) <- c("Var1", "Var2", "Correlation")

# 4. Heatmapa w ggplot2
ggplot(cor_long, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 0,
    limit = c(-1, 1), name = "Korelacja (œÜ)"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    axis.text.x = element_text(angle = 70, vjust = 1, hjust = 1, size = 8),
    axis.text.y = element_text(size = 8),
    axis.title = element_blank(),
    panel.grid = element_blank()
  ) +
  coord_fixed() +
  labs(title = "Macierz korelacji miƒôdzy elementami mapy",
       subtitle = "Dane binarne: 1 = zaznaczone / 0 = nie zaznaczone")
```


## Analiza klastr√≥w

```{r}

# --------------------------
# 0. Zak≈Çadam, ≈ºe masz ju≈º:
# raw_map_data_bin  - wszystkie kolumny (w tym m_scale) zakodowane jako 0/1
# --------------------------

# 1) Konwersja na macierz numerycznƒÖ (upewnienie siƒô)
mat <- as.data.frame(lapply(all_map_data_bin, function(x) as.numeric(as.character(x))))
# zachowaj nazwy zmiennych
vars <- colnames(mat)

# ----- A. Klastrowanie ZMIENNYCH - metoda JACCARD (na transponowanej macierzy) -----
# vegdist dzia≈Ça na wierszach = obserwacjach, wiƒôc transponujemy macierz (zmienne jako wiersze)
dist_vars_jaccard <- vegdist(t(as.matrix(mat)), method = "jaccard", binary = TRUE)

# hierarchiczne klastrowanie (zmienne)
hc_vars_jaccard <- hclust(dist_vars_jaccard, method = "ward.D2")

# wykres dendrogramu
plot(hc_vars_jaccard, main = "Dendrogram zmiennych (Jaccard)", xlab = "", sub = "",  horiz = TRUE)

# przypisanie zmiennych do klastr√≥w (np. k = 4, zmie≈Ñ je≈õli chcesz)
k_vars <- 4
vars_clusters_jaccard <- cutree(hc_vars_jaccard, k = k_vars)
table(vars_clusters_jaccard)

# lista zmiennych w klastrach
split(names(vars_clusters_jaccard), vars_clusters_jaccard)

# ----- B. Klastrowanie ZMIENNYCH - metoda TETRACHORICZNA (korelacje) -----
# tetrachoric wymaga macierzy/ramki 0/1
tet <- tetrachoric(mat)   # mo≈ºe zg≈Çaszaƒá ostrze≈ºenia przy rzadkich kombinacjach
cor_tetra <- tet$rho      # macierz korelacji tetrachoricznej

# utw√≥rz dystans jako 1 - korelacja (mo≈ºna te≈º u≈ºyƒá 1 - abs(cor_tetra) w zale≈ºno≈õci od celu)
dist_vars_tetra <- as.dist(1 - cor_tetra)

hc_vars_tetra <- hclust(dist_vars_tetra, method = "ward.D2")
plot(hc_vars_tetra, main = "Dendrogram zmiennych (tetrachoric)", xlab = "", sub = "",  horiz = TRUE)

# przypisanie do klastr√≥w (u≈ºyj tego samego k lub innego)
vars_clusters_tetra <- cutree(hc_vars_tetra, k = k_vars)
table(vars_clusters_tetra)
split(names(vars_clusters_tetra), vars_clusters_tetra)

# ----- C. Heatmapa korelacji tetrachoricznej uporzƒÖdkowana wg dendrogramu (ggplot2) -----
# wybierz porzƒÖdek zmiennych wg dendrogramu (tutaj u≈ºyjemy hc_vars_tetra)
var_order <- hc_vars_tetra$labels[hc_vars_tetra$order]

# przytnij i przekszta≈Çƒá macierz korelacji do formatu long
cor_long <- as.data.frame(as.table(cor_tetra))
colnames(cor_long) <- c("Var1", "Var2", "Correlation")

# ustaw kolejno≈õƒá faktor√≥w wg porzƒÖdku z dendrogramu
cor_long$Var1 <- factor(cor_long$Var1, levels = var_order)
cor_long$Var2 <- factor(cor_long$Var2, levels = var_order)

# heatmapa w ggplot2
ggplot(cor_long, aes(x = Var1, y = Var2, fill = Correlation)) +
  geom_tile(color = "grey90") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0,
                       limits = c(-1, 1), name = "r (tetrachoric)") +
  geom_text(aes(label = sprintf("%.2f", Correlation)), size = 2) +
  theme_minimal(base_size = 11) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, vjust = 1, size = 8),
        axis.text.y = element_text(size = 8),
        axis.title = element_blank(),
        panel.grid = element_blank()) +
  coord_fixed() +
  labs(title = "Heatmapa korelacji tetrachoricznej (zmienne uporzƒÖdkowane wg dendrogramu)")

# ----- D. Alternatywna heatmapa JACCARD (wsp√≥≈Çwystƒôpowanie) ----- 
# stw√≥rz macierz wsp√≥≈Çwystƒôpowania: transponowana macierz * macierz = liczba wsp√≥lnych '1'
coocc <- t(as.matrix(mat)) %*% as.matrix(mat)
diag(coocc) <- 0
# przekszta≈Çƒá do long i uporzƒÖdkuj wg tego samego porzƒÖdku var_order
coocc_long <- as.data.frame(as.table(coocc))
colnames(coocc_long) <- c("Var1", "Var2", "cooccurrence")
coocc_long$Var1 <- factor(coocc_long$Var1, levels = var_order)
coocc_long$Var2 <- factor(coocc_long$Var2, levels = var_order)

ggplot(coocc_long, aes(x = Var1, y = Var2, fill = cooccurrence)) +
  geom_tile(color = "grey90") +
  geom_text(aes(label = cooccurrence), size = 2) +
  scale_fill_viridis_c(option = "magma") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, vjust = 1, size = 8),
        axis.text.y = element_text(size = 8),
        axis.title = element_blank(),
        panel.grid = element_blank()) +
  coord_fixed() +
  labs(title = "Macierz wsp√≥≈Çwystƒôpowania /n (liczba respondent√≥w zaznaczajƒÖcych obie zmienne)")

# ----- E. Zapis wynik√≥w: przypisz klastrowanie (tetrachoric) do ramki metadanych zmiennych -----
var_clusters_df <- data.frame(
  variable = names(vars_clusters_tetra),
  cluster_tetra = as.integer(vars_clusters_tetra),
  cluster_jaccard = as.integer(vars_clusters_jaccard)
)
print(var_clusters_df)

# (opcjonalnie) zapisz
# write.csv(var_clusters_df, "variable_clusters_map.csv", row.names = FALSE)

```

## Graf

```{r}
# Je≈õli nie masz pakiet√≥w:
# install.packages(c("igraph", "dplyr", "ggraph", "tidygraph", "RColorBrewer"))

library(igraph)
library(ggraph)
library(tidygraph)
library(RColorBrewer)

# --------------------------
# 1Ô∏è‚É£ Dane wej≈õciowe
# Zak≈Çadam, ≈ºe masz raw_map_data_bin (z 0/1, w tym m_scale)
# --------------------------

# macierz wsp√≥≈Çwystƒôpowania (ile razy obie zmienne majƒÖ warto≈õƒá 1)
co_mat <- t(as.matrix(all_map_data_bin)) %*% as.matrix(all_map_data_bin)
diag(co_mat) <- 0  # usu≈Ñ diagonalƒô

# --------------------------
# 2Ô∏è‚É£ Utworzenie grafu
# --------------------------
g <- graph_from_adjacency_matrix(co_mat, weighted = TRUE, mode = "undirected", diag = FALSE)

# --------------------------
# 3Ô∏è‚É£ Filtracja s≈Çabych po≈ÇƒÖcze≈Ñ
# --------------------------
threshold <- 5  # np. tylko po≈ÇƒÖczenia >= 5 wsp√≥≈ÇwystƒÖpie≈Ñ
g_filt <- delete_edges(g, E(g)[weight < threshold])
g_filt <- delete_vertices(g_filt, degree(g_filt) == 0)

# --------------------------
# 4Ô∏è‚É£ Przekszta≈Çcenie do tidygraph
# --------------------------
tg <- as_tbl_graph(g_filt)

# üîπ Obliczenie metryk centralno≈õci
tg <- tg %>%
  mutate(
    degree = centrality_degree(),
    betweenness = centrality_betweenness(),
    strength = strength(graph = g_filt, vids = V(g_filt), weights = E(g_filt)$weight)
  )

# --------------------------
# 5Ô∏è‚É£ Wizualizacja sieci w ggplot (ggraph)
# --------------------------
pal <- brewer.pal(9, "YlGnBu")

set.seed(123)
ggraph(tg, layout = "fr") +
  geom_edge_link(aes(width = weight), alpha = 0.3, color = "grey50") +
  geom_node_point(aes(size = strength, color = betweenness)) +
  geom_node_text(aes(label = name), repel = TRUE, size = 3) +
  scale_edge_width(range = c(0.2, 2)) +
  scale_color_gradientn(colors = pal, name = "Betweenness") +
  theme_void() +
  theme(legend.position = "right") +
  labs(
    title = paste("Sieƒá wsp√≥≈Çwystƒôpowania element√≥w mapy (‚â•", threshold, " wsp√≥lnych)"),
    subtitle = "Kolor = centralno≈õƒá po≈õredniczƒÖca, Rozmiar = si≈Ça po≈ÇƒÖcze≈Ñ"
  )


```

# zale≈ºno≈õƒá od zmiennych obja≈õniajƒÖcych

```{r}

# --- Jeden wykres na zmiennƒÖ obja≈õniajƒÖcƒÖ + testy statystyczne ---
library(tidyverse)
library(rstatix)
library(ggpubr)

# --- Przygotowanie danych (upewnij siƒô, ≈ºe masz wczytane all_data.rda) ---
# load("all_data.rda")

all_map_data <- all_data %>% 
  select(starts_with("m_"), sex, age, education, place, visited_ome, distance_zone, m_scale) %>%
  filter(!is.na(m_scale))

all_map_data_bin <- all_map_data %>%
  select(-m_landmark_chimney) %>% 
  mutate(across(starts_with("m_"), ~ ifelse(. %in% c("tak", "du≈ºa"), 1L,
                                            ifelse(. %in% c("nie", "ma≈Ça"), 0L, NA)))) %>%
  mutate(
    distance_zone = ifelse(distance_zone == 1, "miejscowi",
                           ifelse(distance_zone %in% c(2,3,4), "przyjezdni", NA_character_)),
    distance_zone = factor(distance_zone, levels = c("miejscowi", "przyjezdni"))
  ) %>%
  drop_na()

map_long <- all_map_data_bin %>%
  pivot_longer(cols = starts_with("m_"), names_to = "map_var", values_to = "presence") %>%
  mutate(map_var = factor(map_var, levels = unique(map_var)))

explanatory_vars <- c("sex", "age", "education", "place", "visited_ome", "distance_zone")

combined_plots <- list()
tests_summary <- list()
posthoc_summary <- list()

for (var in explanatory_vars) {
  message("Analizujƒô zmiennƒÖ obja≈õniajƒÖcƒÖ: ", var)
  
  # --- Oblicz ≈õrednie wystƒôpowania (proporcje) ---
  mean_df <- map_long %>%
    group_by(map_var, group = .data[[var]]) %>%
    summarise(mean_presence = mean(presence, na.rm = TRUE),
              n = sum(!is.na(presence)),
              .groups = "drop")
  
  # --- Wykres ---
  p <- ggplot(mean_df, aes(x = map_var, y = mean_presence, fill = as.factor(group))) +
    geom_col(position = position_dodge(width = 0.8), width = 0.7) +
    coord_flip() +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0,1)) +
    labs(
      title = paste("Udzia≈Ç obecno≈õci element√≥w na mapie wg", var),
      x = NULL, y = "Udzia≈Ç obecno≈õci (%)", fill = var
    ) +
    theme_minimal(base_size = 12) +
    theme(plot.title = element_text(face = "bold"), axis.text.y = element_text(size = 9))
  
  combined_plots[[var]] <- p
  
  # --- Testy ---
  map_vars <- unique(map_long$map_var)
  main_res_list <- list()
  posthoc_list <- list()
  
  for (mv in map_vars) {
    df_sub <- map_long %>%
      filter(map_var == mv) %>%
      mutate(group = as.factor(.data[[var]])) %>%
      drop_na(group, presence)
    
    n_groups <- n_distinct(df_sub$group)
    if (nrow(df_sub) == 0 || n_groups < 2) {
      main_res_list[[mv]] <- tibble(map_var = mv, test = NA_character_, p_value = NA_real_, n_groups = n_groups)
      next
    }
    
    if (n_groups == 2) {
      wt <- tryCatch(wilcox_test(df_sub, presence ~ group), error = function(e) NULL)
      pval <- if (!is.null(wt)) wt$p else NA_real_
      main_res_list[[mv]] <- tibble(map_var = mv, test = "Wilcoxon", p_value = pval, n_groups = n_groups)
    } else {
      kt <- tryCatch(kruskal_test(df_sub, presence ~ group), error = function(e) NULL)
      pval <- if (!is.null(kt)) kt$p else NA_real_
      main_res_list[[mv]] <- tibble(map_var = mv, test = "Kruskal-Wallis", p_value = pval, n_groups = n_groups)
      
      if (!is.null(kt) && kt$p < 0.05) {
        counts <- df_sub %>% count(group)
        if (all(counts$n >= 2)) {
          dunn <- tryCatch(
            dunn_test(df_sub, presence ~ group, p.adjust.method = "holm"),
            error = function(e) tibble(map_var = mv, group1 = NA, group2 = NA, p.adj = NA, note = e$message)
          )
          # upewnij siƒô, ≈ºe jest kolumna p.adj
          if (!"p.adj" %in% colnames(dunn)) {
            if ("p.adjusted" %in% colnames(dunn)) dunn <- rename(dunn, p.adj = p.adjusted)
            else dunn$p.adj <- NA_real_
          }
          dunn <- mutate(dunn, map_var = mv)
          posthoc_list[[mv]] <- dunn
        }
      }
    }
  }
  
  main_res_df <- bind_rows(main_res_list) %>%
    mutate(variable = var,
           p_value_adj = ifelse(!is.na(p_value), p.adjust(p_value, method = "holm"), NA_real_),
           significant = ifelse(!is.na(p_value_adj) & p_value_adj < 0.05, TRUE, FALSE)) %>%
    select(variable, everything())
  
  tests_summary[[var]] <- main_res_df
  posthoc_df <- if (length(posthoc_list) > 0) bind_rows(posthoc_list) else tibble()
  posthoc_summary[[var]] <- posthoc_df
  
  # --- Wypisywanie wynik√≥w ---
  cat("\n=== Wyniki g≈Ç√≥wne dla:", var, "===\n")
  print(main_res_df %>% filter(!is.na(p_value)) %>% arrange(p_value_adj) %>% head(10))
  
  if (nrow(posthoc_df) > 0 && "p.adj" %in% colnames(posthoc_df)) {
    cat("\n--- Istotne por√≥wnania post-hoc (Dunn) dla", var, "---\n")
    print(posthoc_df %>% filter(!is.na(p.adj), p.adj < 0.05))
  } else {
    cat("\nBrak istotnych wynik√≥w post-hoc lub brak kolumny p.adj dla:", var, "\n")
  }
}

# --- Zbiorcze tabele wynik√≥w ---
all_tests_main_df <- bind_rows(tests_summary)
all_posthoc_df <- bind_rows(posthoc_summary, .id = "variable")

# Przyk≈Çadowe wy≈õwietlenie wykresu:
combined_plots$sex
combined_plots$age
combined_plots$education
combined_plots$place
combined_plots$visited_ome
combined_plots$distance_zone



# Pr√≥ba okre≈õlenia, kt√≥re zmienne obja≈õniajƒÖce majƒÖ najwiƒôkszy wp≈Çyw
all_tests_main_df <- all_tests_main_df %>% 
  mutate(significant_pre_ajd = ifelse(p_value < 0.05, TRUE, FALSE))

influence_summary <- all_tests_main_df %>%
  group_by(variable) %>%
  summarise(
    n_significant = sum(significant, na.rm = TRUE),
    n_total = n(),
    share_significant = n_significant / n_total
  ) %>%
  arrange(desc(n_significant))
```




# zale≈ºno≈õƒá od zmiennej visited_ome

```{r}
# --- Compute differences visited_ome (Tak - Nie)
diff_df <- map_long %>%
  select(map_var, visited_ome, presence) %>%
  group_by(map_var, visited_ome) %>%
  summarise(mean_presence = mean(presence, na.rm = TRUE), .groups = "drop") %>%
  tidyr::pivot_wider(
    names_from = visited_ome,
    values_from = mean_presence
  ) %>%
  mutate(Tak_Nie = Tak - Nie) %>% 
  arrange(desc(Tak_Nie)) %>%
  mutate(
    Tak  = scales::percent(Tak,  accuracy = 0.1, decimal.mark = ","),
    Nie  = scales::percent(Nie,  accuracy = 0.1, decimal.mark = ","),
    Tak_Nie = scales::percent(Tak_Nie,
                                         accuracy = 0.1,
                                         decimal.mark = ",")
  ) %>%
  print()
  


# --- Compute overall mean per map_var ---
overall_means <- map_long %>%
  group_by(map_var) %>%
  summarise(overall_mean = mean(presence, na.rm = TRUE), .groups = "drop")

# --- Renames labels for chart ---
map_labels <- c(
  m_scale                = "Scale",
  m_border               = "Border",
  m_path_asphalt         = "Asphalt path",
  m_path_nature          = "Nature path",
  m_path_other           = "Other path",
  m_edges_border         = "Edges: border",
  m_edges_river          = "Edges: river",
  m_circles_lake         = "Circle: Lake",
  m_circles_meadow       = "Circle: Meadow",
  m_nodes_parking        = "Parking",
  m_nodes_town           = "Town",
  m_nodes_headquarters   = "Headquarters",
  m_nodes_ome            = "OME",
  m_landmark_tower       = "Tower",
  m_landmark_shelter     = "Shelter",
  m_landmark_birdhide    = "Bird hide",
  m_landmark_bench       = "Bench",
  m_landmark_bridge      = "Bridge",
  m_landmark_ferry       = "Ferry",
  m_landmark_pump_station = "Pump station",
  m_landmark_info_board  = "Info board",
  m_landmark_footbridge  = "Footbridge",
  m_event_observation    = "Observation event",
  m_event_people         = "People event"
)

# --- Wykres ---
map_long %>%
    select(visited_ome, map_var, presence) %>% 
    left_join(overall_means, by = "map_var") %>%
    mutate(map_var = reorder(map_var, overall_mean)) %>%
    group_by(map_var, visited_ome) %>%
    summarise(mean_presence = mean(presence, na.rm = TRUE),
              n = sum(!is.na(presence)),
              .groups = "drop") %>% 
    mutate(map_var = recode(map_var, !!!map_labels)) %>%
    ggplot(aes(x = map_var, y = mean_presence, fill = visited_ome)) +
      geom_col(position = position_dodge(width = 0.8), width = 0.7) +
      geom_text(
        aes(label = scales::percent(mean_presence, accuracy = 0.1)),
        position = position_dodge(width = 0.8),
        hjust = -0.1, size = 3, color = "black"
      ) +
      coord_flip() +
      scale_y_continuous(
        labels = scales::percent_format(accuracy = 1), 
        breaks = seq(0, 1, by = 0.1),
        limits = c(0,1)
      ) +
      labs(
        title = "Udzia≈Ç obecno≈õci element√≥w na mapie wg odwiedzin w OME",
        x = NULL, y = "Udzia≈Ç obecno≈õci (%)", fill = "Odwiedzi≈Ç OME"
      ) +
      theme_minimal(base_size = 12) +
      theme(plot.title = element_text(face = "bold"), 
            axis.text.y = element_text(size = 9),
            )




# --- Testy ---
map_vars <- unique(map_long$map_var)
results <- list()

for (mv in map_vars) {
  
  df_sub <- map_long %>%
    filter(map_var == mv) %>%
    mutate(group = as.factor(visited_ome)) %>%
    drop_na(group, presence)
  
  # Je≈õli dane nie pozwalajƒÖ na test ‚Äî pomi≈Ñ
  if (nrow(df_sub) == 0 || n_distinct(df_sub$group) < 2) {
    results[[mv]] <- tibble(
      map_var = mv,
      test = "Wilcoxon",
      p_value = NA_real_,
      n_groups = n_distinct(df_sub$group)
    )
    next
  }
  
  wt <- tryCatch(
    wilcox_test(df_sub, presence ~ group),
    error = function(e) NULL
  )
  
  pval <- if (!is.null(wt)) wt$p else NA_real_
  
  results[[mv]] <- tibble(
    map_var = mv,
    test = "Wilcoxon",
    p_value = pval,
    n_groups = 2
  )
}

main_res_df <- bind_rows(results) %>%
  mutate(
    variable = "visited_ome",
    p_value_adj = p.adjust(p_value, method = "holm"),
    significant = p_value_adj < 0.05
  ) %>%
  select(variable, everything())

# --- Wyniki ---
cat("\n=== Wyniki g≈Ç√≥wne dla visited_ome ===\n")
print(main_res_df %>% arrange(p_value_adj))

cat("\n--- Post-hoc ---\n")
cat("Nie dotyczy ‚Äî tylko 2 grupy, brak post-hoc.\n")

```

## Wizualizacja w tabeli

```{r}
diff_df %>%
  gt() %>%
  # Dodaj tytu≈Ç tabeli
  tab_header(
    title = "Udzia≈Ç obecno≈õci element√≥w na mapie w≈õr√≥d os√≥b, kt√≥re odwiedzi≈Çy i nie odwiedzi≈Çy OME"
  ) %>%
  # Dodaj podtytu≈Ç z opisem kolumn
  tab_spanner(
    label = "Odsetek odpowiedzi",
    columns = c(Tak, Nie)
  ) %>%
  # Zmie≈Ñ nazwy kolumn
  cols_label(
    map_var = "Element na mapie",
    Tak = "Odwiedzili OME",
    Nie = "Nie odwiedzili OME",
    Tak_Nie = "R√≥≈ºnica (Tak - Nie)"
  ) %>%
  # Sformatuj kom√≥rki - wyr√≥wnanie
  cols_align(
    align = "left",
    columns = map_var
  ) %>%
  cols_align(
    align = "center",
    columns = c(Tak, Nie, Tak_Nie)
  ) %>%
  # Opcjonalnie: pogrub warto≈õci r√≥≈ºnicy dla lepszej czytelno≈õci
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(columns = Tak_Nie)
  ) %>%
  # Opcjonalnie: dodaj obramowanie
  tab_style(
    style = cell_borders(sides = "bottom", color = "#D3D3D3", weight = px(1)),
    locations = cells_body(rows = everything())
  ) %>%
  # Dodaj footnotes z wyja≈õnieniami
  tab_footnote(
    footnote = "OME - Obiekt/Miejsce Edukacyjne",
    locations = cells_title(groups = "title")
  ) %>%
  tab_footnote(
    footnote = "R√≥≈ºnica obliczona jako: Tak - Nie",
    locations = cells_column_labels(columns = Tak_Nie)
  ) %>%
  # Opcjonalnie: dodaj kolory do kolumny r√≥≈ºnicy
  # (zielony dla dodatnich, czerwony dla ujemnych, szary dla zer)
  data_color(
    columns = Tak_Nie,
    fn = function(x) {
      # Usu≈Ñ znaki % i zamie≈Ñ przecinki na kropki, konwertuj na liczby
      values <- as.numeric(gsub(",", ".", gsub("%", "", x)))
      
      # Utw√≥rz paletƒô kolor√≥w
      colors <- case_when(
        values > 0 ~ "#d9f2e6",  # jasny zielony
        values < 0 ~ "#ffe6e6",  # jasny czerwony
        TRUE ~ "#f2f2f2"         # jasny szary
      )
      colors
    }
  ) %>%
  # Ustaw szeroko≈õƒá kolumn
  cols_width(
    map_var ~ px(250),
    Tak ~ px(120),
    Nie ~ px(120),
    Tak_Nie ~ px(140)
  ) %>%
  # Dodaj stylowanie wiersz co drugi dla lepszej czytelno≈õci
  opt_row_striping()
```


# zale≈ºno≈õƒá od zmiennej place

```{r}
# --- Wykres ---
map_long %>%
    select(place, map_var, presence) %>% 
    left_join(overall_means, by = "map_var") %>%
    mutate(map_var = reorder(map_var, overall_mean)) %>%
    group_by(map_var, place) %>%
    summarise(mean_presence = mean(presence, na.rm = TRUE),
              n = sum(!is.na(presence)),
              .groups = "drop") %>% 
    mutate(map_var = recode(map_var, !!!map_labels)) %>%
    ggplot(aes(x = map_var, y = mean_presence, fill = place)) +
      geom_col(position = position_dodge(width = 0.8), width = 0.7) +
      geom_text(
        aes(label = scales::percent(mean_presence, accuracy = 0.1)),
        position = position_dodge(width = 0.8),
        hjust = -0.1, size = 3, color = "black"
      ) +
      coord_flip() +
      scale_y_continuous(
        labels = scales::percent_format(accuracy = 1), 
        breaks = seq(0, 1, by = 0.1),
        limits = c(0,1)
      ) +
      labs(
        title = "Udzia≈Ç obecno≈õci element√≥w na mapie wg miejsca ankietowania",
        x = NULL, y = "Udzia≈Ç obecno≈õci (%)", fill = "miejsce ankietowania"
      ) +
      theme_minimal(base_size = 12) +
      theme(plot.title = element_text(face = "bold"), 
            axis.text.y = element_text(size = 9),
            )

```

## tabela zbiorcza w DT:datatable()

```{r}
# funkcja do obliczania (aby nie powielaƒá kodu ni≈ºej)
compute_diff <- function(data, group_var, level_pos, level_neg, diff_name) {
  
  data %>%
    select(map_var, {{ group_var }}, presence) %>%
    group_by(map_var, {{ group_var }}) %>%
    summarise(mean_presence = mean(presence, na.rm = TRUE), .groups = "drop") %>%
    tidyr::pivot_wider(
      names_from  = {{ group_var }},
      values_from = mean_presence
    ) %>%
    mutate(
      !!diff_name := .data[[level_pos]] - .data[[level_neg]]
    ) %>%
    rename(
      !!level_pos := all_of(level_pos),
      !!level_neg := all_of(level_neg)
    )
}

# R√≥≈ºnice: visited_ome (Tak ‚Äì Nie)
diff_visited <- compute_diff(
  data      = map_long,
  group_var = visited_ome,
  level_pos = "Tak",
  level_neg = "Nie",
  diff_name = "Tak_Nie"
)


# R√≥≈ºnice: place (Betonka ‚Äì Olszynki)

diff_place <- compute_diff(
  data      = map_long,
  group_var = place,
  level_pos = "Betonka",
  level_neg = "Olszynki",
  diff_name = "Betonka_Olszynki"
)

# po≈ÇƒÖczenie w jednƒÖ tabelƒô po diff_place
diff_df <- diff_visited %>%
  left_join(diff_place, by = "map_var") %>%
  arrange(desc(Tak_Nie)) %>% 
  mutate(OME_yes__Betonka = Tak - Betonka)

DT::datatable(
  diff_df,
  options = list(
    pageLength = 25,      # pokazuje 25 wierszy na stronƒô
    scrollX = TRUE,       # poziome przewijanie
    searchHighlight = TRUE # pod≈õwietla wyniki wyszukiwania
  ),
  rownames = FALSE        # bez nazw wierszy
  ) %>%
  DT::formatPercentage(
    columns = names(diff_df)[sapply(diff_df, is.numeric)],
    digits = 1
  )

```

## tabela zbiorcza w gt()

```{r}
# Stw√≥rz tabelƒô gt
gt_table <- diff_df %>%
  # Konwertuj wszystkie warto≈õci liczbowe na procenty z 1 miejscem po przecinku
  mutate(across(where(is.numeric), ~ scales::percent(.x, accuracy = 0.1, decimal.mark = ","))) %>%
  gt() %>%
  # Tytu≈Ç tabeli
  tab_header(
    title = "R√≥≈ºnice w udziale obecno≈õci element√≥w na mapie",
    subtitle = "Por√≥wnanie miƒôdzy grupami wed≈Çug odwiedzin OME oraz miejsca ankietowania"
  ) %>%
  # Nag≈Ç√≥wki grup kolumn
  tab_spanner(
    label = "Odwiedzi≈Ç OME",
    columns = c(Tak, Nie, Tak_Nie)
  ) %>%
  tab_spanner(
    label = "Miejsce ankietowania",
    columns = c(Betonka, Olszynki, Betonka_Olszynki)
  ) %>%
  tab_spanner(
    label = "Dodatkowe por√≥wnanie",
    columns = OME_yes__Betonka
  ) %>%
  # Etykiety kolumn
  cols_label(
    map_var = "Element na mapie",
    Tak = "Tak",
    Nie = "Nie",
    Tak_Nie = "R√≥≈ºnica (T-N)",
    Betonka = "Betonka",
    Olszynki = "Olszynki",
    Betonka_Olszynki = "R√≥≈ºnica (B-O)",
    OME_yes__Betonka = "Tak (OME) - Betonka"
  ) %>%
  # Wyr√≥wnanie
  cols_align(
    align = "left",
    columns = map_var
  ) %>%
  cols_align(
    align = "center",
    columns = where(is.character)
  ) %>%
  # Stylowanie kom√≥rek dla r√≥≈ºnic
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(columns = c(Tak_Nie, Betonka_Olszynki, OME_yes__Betonka))
  ) %>%
  # Kolorowanie r√≥≈ºnic
  data_color(
    columns = c(Tak_Nie, Betonka_Olszynki, OME_yes__Betonka),
    fn = function(x) {
      # Usu≈Ñ znak % i zamie≈Ñ przecinek na kropkƒô
      values <- as.numeric(gsub("%", "", gsub(",", ".", x)))
      
      # Dla warto≈õci liczbowych (r√≥≈ºnic)
      case_when(
        values > 0 ~ "#e6f3ff",      # jasny niebieski dla dodatnich
        values < 0 ~ "#ffe6e6",      # jasny czerwony dla ujemnych
        TRUE ~ "#f0f0f0"             # szary dla zer
      )
    }
  ) %>%
  # Obramowanie miƒôdzy sekcjami
  tab_style(
    style = cell_borders(sides = "right", color = "#D3D3D3", weight = px(2)),
    locations = list(
      cells_body(columns = Tak_Nie),
      cells_body(columns = Betonka_Olszynki)
    )
  ) %>%
  # Stopka z wyja≈õnieniami
  tab_footnote(
    footnote = "T-N: r√≥≈ºnica miƒôdzy osobami kt√≥re odwiedzi≈Çy OME (Tak) i nie (Nie)",
    locations = cells_column_labels(columns = Tak_Nie)
  ) %>%
  tab_footnote(
    footnote = "B-O: r√≥≈ºnica miƒôdzy osobami ankietowanymi na Betonce i w Olszynkach",
    locations = cells_column_labels(columns = Betonka_Olszynki)
  ) %>%
  tab_footnote(
    footnote = "R√≥≈ºnica miƒôdzy osobami kt√≥re odwiedzi≈Çy OME a osobami ankietowanymi na Betonce",
    locations = cells_column_labels(columns = OME_yes__Betonka)
  ) %>%
  # Opcje stylistyczne
  tab_options(
    table.font.size = 12,
    column_labels.font.weight = "bold",
    table_body.hlines.color = "white",
    table_body.vlines.color = "white",
    heading.title.font.size = 16,
    heading.subtitle.font.size = 14
  ) %>%
  # Naprzemienne kolorowanie wierszy dla lepszej czytelno≈õci
  opt_row_striping()

# Wy≈õwietl tabelƒô
gt_table
```



